generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enum for user roles
enum Role {
  USER
  ADMIN
}

// Enum for book status
enum Status {
  ONGOING    // In progress
  COMPLETED  // Completed
  HIATUS     // Hiatus
  PAUSED     // Paused
}

// User model
model User {
  id          String   @id @default(cuid())
  name        String
  email       String   @unique
  password    String? // Nullable: will be null for Google accounts
  image       String? // Profile image URL
  description String?
  role        Role     @default(USER)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Future relationships (example)
  // books         Book[]   @relation("UserBooks")
  // followedBooks Book[]   @relation("BookFollowers")

  // Fields for NextAuth
  emailVerified DateTime?
  accounts      Account[]
  sessions      Session[]

  // Relationships with books
  books   Book[] @relation("AuthorBooks")

  // Follows: books this user follows
  follows BookFollow[]

  // Ratings given by this user
  ratings BookRating[]

  // Comments authored by this user
  comments Comment[]

  // Comment likes by this user
  commentLikes CommentLike[]

  // Password recovery
  passwordResetTokens PasswordResetToken[]

  // Credential version: incremented when credentials change (forces JWT re-login)
  credentialVersion Int @default(0)

  // Chapter views created by this user
  chapterViews ChapterView[]
}

// Literary genre model
model Genre {
  id    String  @id @default(cuid())
  name  String  @unique
  books Book[]  @relation("BookGenres")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Book model
model Book {
  id              String    @id @default(cuid())
  title           String    @db.VarChar(200)
  synopsis        String    @db.VarChar(2000)
  releaseFrequency String?  @db.VarChar(50)
  coverUrl        String?
  status          Status    @default(ONGOING)
  views           Int       @default(0)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Author
  authorId String
  author   User      @relation("AuthorBooks", fields: [authorId], references: [id], onDelete: Cascade)

  // Genres
  genres   Genre[]   @relation("BookGenres")

  // Followers: users who follow this book
  followers BookFollow[]

  // Ratings received by this book
  ratings BookRating[]

  // Volumes and chapters
  volumes  Volume[]
  chapters Chapter[]

  // Comments on this book
  comments Comment[]
}

// Auxiliary models for NextAuth
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Password reset token (single use)
model PasswordResetToken {
  id         String   @id @default(cuid())
  userId     String
  tokenHash  String   @unique
  expires    DateTime
  createdAt  DateTime @default(now())
  consumedAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Explicit join model for user follows on books
model BookFollow {
  userId   String
  bookId   String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  book Book @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@id([userId, bookId])
  @@index([bookId])
}

// Explicit join model for user ratings on books (1..5 stars)
model BookRating {
  userId   String
  bookId   String
  score    Int // 1..5
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  book Book @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@id([userId, bookId])
  @@index([bookId])
}

// Volume groups chapters inside a book. Deleting a volume should not delete chapters; they become unassigned.
model Volume {
  id        String   @id @default(cuid())
  title     String   @db.VarChar(200)
  order     Int      @default(0)
  bookId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  book      Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  chapters  Chapter[]

  @@index([bookId])
}

// Chapter belongs to a book and may optionally belong to a volume.
model Chapter {
  id        String    @id @default(cuid())
  title     String    @db.VarChar(200)
  content   String    @db.Text
  order     Int       @default(0)
  bookId    String
  volumeId  String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  book     Book    @relation(fields: [bookId], references: [id], onDelete: Cascade)
  volume   Volume? @relation(fields: [volumeId], references: [id], onDelete: SetNull)

  // Comments on this chapter
  comments Comment[]

  // Views on this chapter
  views ChapterView[]

  @@index([bookId])
  @@index([volumeId])
}

// User comments on books and chapters. Replies are modeled via self-relation (parentId).
model Comment {
  id        String   @id @default(cuid())
  content   String   @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Author
  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Target book (required)
  bookId String
  book   Book  @relation(fields: [bookId], references: [id], onDelete: Cascade)

  // Optional chapter when the comment is for a specific chapter
  chapterId String?
  chapter   Chapter? @relation(fields: [chapterId], references: [id], onDelete: SetNull)

  // Replies
  parentId String?
  parent   Comment? @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies  Comment[] @relation("CommentReplies")

  likes CommentLike[]

  @@index([bookId])
  @@index([chapterId])
  @@index([parentId])
}

// A user can like a comment at most once
model CommentLike {
  userId    String
  commentId String
  createdAt DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@id([userId, commentId])
  @@index([commentId])
}

// Track chapter views: authenticated-only, each view tied to a userId
model ChapterView {
  id        String   @id @default(cuid())
  chapterId String
  userId    String   // authenticated-only: every view is tied to a user
  createdAt DateTime @default(now())

  chapter Chapter @relation(fields: [chapterId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([chapterId])
  @@index([chapterId, createdAt])
  @@index([chapterId, userId, createdAt])
}
