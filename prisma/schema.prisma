// Notificações do sistema
enum NotificationType {
  BOOK_COMMENT
  CHAPTER_COMMENT
  COMMENT_REPLY
  NEW_CHAPTER
}

// Reactions on books (one per user per book)
enum ReactionType {
  JOY
  LOVE
  FEAR
  SADNESS
  ANGER
}

model Notification {
  id            String           @id @default(cuid())
  userId        String
  type          NotificationType
  bookId        String?
  chapterId     String?
  commentId     String?
  replyId       String?
  createdAt     DateTime         @default(now())
  checked       Boolean          @default(false)
  // Dados para renderização rápida
  bookTitle     String?
  bookCoverUrl  String?
  chapterTitle  String?
  authorName    String?
  commenterName String?
  commentContent String?
  replyContent  String?
  originalComment String?
  chapterSnippet String?

  user          User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  book          Book?            @relation(fields: [bookId], references: [id], onDelete: Cascade)
  chapter       Chapter?         @relation(fields: [chapterId], references: [id], onDelete: Cascade)
  comment       Comment?         @relation("NotificationComment", fields: [commentId], references: [id], onDelete: Cascade)
  reply         Comment?         @relation("NotificationReply", fields: [replyId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([bookId])
  @@index([chapterId])
  @@index([commentId])
  @@index([replyId])
}
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enum for user roles
enum Role {
  USER
  ADMIN
}

// Enum for book status
enum Status {
  ONGOING    // In progress
  COMPLETED  // Completed
  HIATUS     // Hiatus
  PAUSED     // Paused
}

// Enum for report types on comments (denúncias)
enum ReportType {
  INCONVENIENT_CONTENT          // Conteúdo inconveniente
  THREAT_OR_INTIMIDATION        // Ameaça, intimidação ou abordagem imprópria
  RISK_TO_INTEGRITY             // Risco à integridade física ou emocional
  INAPPROPRIATE_SEXUAL_CONTENT  // Material sexual inadequado
  OFFENSIVE_OR_DISCRIMINATORY   // Discurso ofensivo ou discriminatório
  VIOLENCE_OR_EXPLOITATION      // Ato violento ou exploração de vulneráveis
  PROHIBITED_ITEMS              // Divulgação de itens proibidos
  FRAUD_OR_SUSPICIOUS_ACTIVITY  // Tentativa de engano ou atividade suspeita
  MISLEADING_INFORMATION        // Informação duvidosa ou enganosa
}

// User model
model User {
  id          String   @id @default(cuid())
  name        String
  email       String   @unique
  password    String? // Nullable: will be null for Google accounts
  image       String? // Profile image URL
  description String?
  role        Role     @default(USER)
  blocked     Boolean  @default(false) // Field to block user login
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Future relationships (example)
  // books         Book[]   @relation("UserBooks")
  // followedBooks Book[]   @relation("BookFollowers")

  // Fields for NextAuth
  emailVerified DateTime?
  accounts      Account[]
  sessions      Session[]

  // Relationships with books
  books   Book[] @relation("AuthorBooks")

  // Follows: books this user follows
  follows BookFollow[]

  // Ratings given by this user
  ratings BookRating[]

  // Comments authored by this user
  comments Comment[]

  // Comment likes by this user
  commentLikes CommentLike[]

  // Password recovery
  passwordResetTokens PasswordResetToken[]

  // Credential version: incremented when credentials change (forces JWT re-login)
  credentialVersion Int @default(0)

  // Chapter views by this user
  chapterViews ChapterView[]

  // Notificações recebidas
  notifications Notification[]

  // Reactions given by this user (one per book)
  reactions Reaction[]

  // Profile image (stored as base64 in separate table)
  profileImage ProfileImage?
}

// Literary genre model
model Genre {
  id    String  @id @default(cuid())
  name  String  @unique
  books Book[]  @relation("BookGenres")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Book model
model Book {
  id              String    @id @default(cuid())
  slug            String?   @unique @db.VarChar(220)
  title           String    @db.VarChar(200)
  synopsis        String    @db.VarChar(2000)
  releaseFrequency String?  @db.VarChar(50)
  coverUrl        String?
  status          Status    @default(ONGOING)
  views           Int       @default(0)
  // Aggregates for performance
  totalViews      Int       @default(0)
  ratingSum       Int       @default(0)   // sum of scores (1..5)
  ratingCount     Int       @default(0)   // number of ratings
  ratingAvg       Float     @default(0)   // denormalized average for quick reads
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Author
  authorId String
  author   User      @relation("AuthorBooks", fields: [authorId], references: [id], onDelete: Cascade)

  // Genres
  genres   Genre[]   @relation("BookGenres")

  // Followers: users who follow this book
  followers BookFollow[]

  // Ratings received by this book
  ratings BookRating[]

  // Volumes and chapters
  volumes  Volume[]
  chapters Chapter[]

  // Comments on this book
  comments Comment[]

  // Reactions on this book
  reactions Reaction[]

  // Notificações relacionadas a este livro
  notifications Notification[]
}

// Auxiliary models for NextAuth
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Password reset token (single use)
model PasswordResetToken {
  id         String   @id @default(cuid())
  userId     String
  tokenHash  String   @unique
  expires    DateTime
  createdAt  DateTime @default(now())
  consumedAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Explicit join model for user follows on books
model BookFollow {
  userId   String
  bookId   String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  book Book @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@id([userId, bookId])
  @@index([bookId])
}

// Explicit join model for user ratings on books (1..5 stars)
model BookRating {
  userId   String
  bookId   String
  score    Int // 1..5
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  book Book @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@id([userId, bookId])
  @@index([bookId])
}

// Volume groups chapters inside a book. Deleting a volume should not delete chapters; they become unassigned.
model Volume {
  id        String   @id @default(cuid())
  title     String   @db.VarChar(200)
  order     Int      @default(0)
  bookId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  book      Book     @relation(fields: [bookId], references: [id], onDelete: Cascade)
  chapters  Chapter[]

  @@index([bookId])
}

// Chapter belongs to a book and may optionally belong to a volume.
model Chapter {
  id        String    @id @default(cuid())
  title     String    @db.VarChar(200)
  content   String    @db.Text
  order     Int       @default(0)
  bookId    String
  volumeId  String?
  // Aggregate for performance
  totalViews Int      @default(0)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  book     Book    @relation(fields: [bookId], references: [id], onDelete: Cascade)
  volume   Volume? @relation(fields: [volumeId], references: [id], onDelete: SetNull)

  // Comments on this chapter
  comments Comment[]

  // Views for this chapter
  views ChapterView[]

  // Notificações relacionadas a este capítulo
  notifications Notification[]

  @@index([bookId])
  @@index([volumeId])
}

// User comments on books and chapters. Replies are modeled via self-relation (parentId).
model Comment {
  id        String   @id @default(cuid())
  content   String   @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Author
  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Target book (required)
  bookId String
  book   Book  @relation(fields: [bookId], references: [id], onDelete: Cascade)

  // Optional chapter when the comment is for a specific chapter
  chapterId String?
  chapter   Chapter? @relation(fields: [chapterId], references: [id], onDelete: SetNull)

  // Replies
  parentId String?
  parent   Comment? @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies  Comment[] @relation("CommentReplies")

  likes CommentLike[]

  // Notificações relacionadas a este comentário
  notificationComments Notification[] @relation("NotificationComment")
  notificationReplies Notification[] @relation("NotificationReply")

  // Reports (denúncias) against this comment
  reports CommentReport[]

  @@index([bookId])
  @@index([chapterId])
  @@index([parentId])
}

// A user can like a comment at most once
model CommentLike {
  userId    String
  commentId String
  createdAt DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@id([userId, commentId])
  @@index([commentId])
}

// Anonymous reports for comments. Reporter identity is NOT stored to protect users.
model CommentReport {
  id        String     @id @default(cuid())
  commentId String
  type      ReportType
  createdAt DateTime   @default(now())

  comment   Comment    @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@index([commentId, createdAt])
}

// Views per chapter, auth-only (no IP storage). This mirrors the shared DB table
model ChapterView {
  id        String   @id @default(cuid())
  chapterId String
  userId    String
  createdAt DateTime @default(now())

  chapter Chapter @relation(fields: [chapterId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([chapterId])
  @@index([chapterId, createdAt])
  @@index([chapterId, userId, createdAt])
}

// Homepage banners
model Banner {
  id        String   @id @default(cuid())
  name      String   @db.VarChar(200)
  imageUrl  String   @db.VarChar(1000)
  linkUrl   String   @db.VarChar(1000)
  position  Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Stores raw profile images as base64 for simplicity
model ProfileImage {
  id        String   @id @default(cuid())
  userId    String   @unique
  imageData String
  mimeType  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// A user's single reaction per book (can be changed). Aggregations are computed on demand for now.
model Reaction {
  id        String       @id @default(cuid())
  userId    String
  bookId    String
  type      ReactionType
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  book Book @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@unique([userId, bookId])
  @@index([bookId])
  @@index([userId])
}
